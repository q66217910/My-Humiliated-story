类加载机制
===
类加载的本质:将描述类的数据,从Class文件加载到内存&对数据进行校验、转换解析和初始化，
最终形成可被虚拟机直接使用的java使用类型


1.加载过程
---
    加载-> 验证-> 准备->解析->初始化->使用->卸载

2.加载
---
 获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象0
    1.通过一个类的全限定名来获取其定义的二进制字节流
    2.将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
    3.在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

3.验证
---
验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全

    1.文件格式的验证
    2.元数据验证
    3.字节码验证
    4.符号引用验证

4.准备
---
为类变量分配内存并设置初始值

    1.类变量（static）会分配内存，但是实例变量不会，
      实例变量主要随着对象的实例化一块分配到java堆中.
    2.这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。

5.解析
---
将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针

    1.符号引用
    2.直接引用

6.初始化
---
初始化阶段是执行类构造器<client>方法的过程

    java中，对于初始化阶段，有且只有以下五种情况才会对要求类立刻“初始化”
    1.使用new关键字实例化对象、访问或者设置一个类的静态字段（
    被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，
    都会初始化该静态字段或者静态方法所在的类。
    2.初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。
    3.使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化
    4.虚拟机启动时，用户会先初始化要执行的主类（含有main）
    5.jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果
    是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，
    并且这个方法所在类没有初始化，则先初始化。

####  初始化顺序：

1. static对象和static块
2. 成员变量代码块
3. 构造函数
4. 成员函数

类加载器
---
类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。

    1.根类加载器：它用来加载 Java 的核心类，
    是用原生代码来实现的，并不继承自 java.lang.ClassLoader
    （负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，
    由C++实现，不是ClassLoader子类）
    2.扩展类加载器：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。
    由Java语言实现，父类加载器为null。
    3.系统类加载器：被称为系统（也称为应用）类加载器，
    它负责在JVM启动时加载来自Java命令的-classpath选项、
    java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。
    程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。


​    
JVM的类加载机制：

    1.全盘负责：当一个类加载器负责加载某个Class时，
    该Class所依赖和引用其他Class也将由该类加载器负责载入，
    除非显示使用另外一个类加载器来载入
    2.双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，
    只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
    3.缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，
    当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，
    只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，
    并将其转换成Class对象，存入缓冲区中。

双亲委派机制的优势:
---

    1.采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，
    通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，
    就没有必要子ClassLoader再加载一次。
    2.安全因素，java核心api中定义类型不会被随意替换


