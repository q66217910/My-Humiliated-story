# 红黑树
1.二叉查找树

2.完美平衡二叉树

由来
---

    红黑树是由二叉搜索树演变而已，二叉搜索树(一个节点，左节点小于它，右节点大于它),而由于二叉搜索树容易偏向一边，
    导致数据不平衡，从而导致查询效率不理想，平衡树就孕育而生。而红黑树的逻辑其实是2-3树。2-3树中，2代表2节点(a,b),
    3代表(小于a,介于a，b,大于b),在红黑树中,将(小于a,介于a，b)做为a节点的左节点和右节点，(a与大于b)为b的左节点和
    右节点,在a,b之间的连接则为红连接,b点为红节点。而红黑树也达到了黑色平衡。

 [红黑树的演变](https://www.cnblogs.com/tiancai/p/9072813.html)
    
性质
---

    1.每个节点要么是黑色，要么是红色。
    2.根节点(root)是黑色。
    3.每个叶子节点（NIL）是黑色。
    4.每个红色结点的两个子结点一定都是黑色。
    5.任意一结点到每个叶子结点的路径都包含数量相同的黑结点

红黑树自平衡
------

    1.左旋:以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，
    右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
    2.以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，
    左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
    3.变色：结点的颜色由红变黑或由黑变红。

红黑树查找(O(logn))
--------------

    1.从根结点开始查找，把根结点设置为当前结点；
    2.若当前结点为空，返回null；
    3.若当前结点不为空，用当前结点的key跟查找key作比较；
    4.(=)若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
    5.(>,左子树)若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
    6.(<,右子树)若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；

红黑树插入 *
-------

    红黑树的插入与查找相当，若root节点不存在时，插入节点并设置为根节点。
    根据红黑树查找的方法查找key的值，若找到则更新值，若是没有找到,则在正确的位置，插入
    新节点。至此就插入一个新的节点（新节点默认红色），但是有可能会导致红黑树不平衡，所以插入时需要红黑树的
    自平衡。

红黑树插入自平衡
------

    1.若父节点是黑色节点，不需要做任何处理，自身平衡。
    2.若父节点是红色节点，则需要自平衡处理
        2.1:叔叔节点存在并为红色节点 (将父节点和叔叔节点都设置为黑色,将祖父节点设置为红色,将祖父节点设置为当前节点,向上平衡)
        2.2:叔叔节点不存在或者为黑色节点
            2.2.1:父节点是祖父节点的左节点
                2.2.1.1:节点是父节的左节点  (父节点设置成黑色，祖父节点为红色，对祖父节点进行右旋)
                2.2.1.2:节点是父节的右节点  (先对父节点进行左旋,把父节点当作插入节点，进行2.2.1.1操作)            
            2.2.2:父节点是祖父节点的右节点 
                 2.2.2.1：结点父结点的右结点  (父节点设置成黑色，祖父节点为红色,对祖父节点进行右旋)
                 2.2.2.2：结点父结点的左结点  (先对父节点进行右旋,把父节点当作插入节点，进行2.2.2.1操作)  

红黑树删除
-----

    查找节点,并删除该节点。
    1.若删除节点,无子节点，直接删除
    2.若删除节点，只有一个节点，则子节点替换删除节点
    3.若删除节点，有两个子节点，则用后继节点替换删除节点




[推荐文章](https://www.jianshu.com/p/e136ec79235c)

[ConcurrentHashMap 红黑树实现](https://github.com/q66217910/My-Humiliated-story/blob/master/java/set/ConcurrentHashMap.md)

    