redis过期策略
===

    volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key。
    allkeys-lru ：移除最近最少使用的key
    volatile-random： 在设置了过期时间的键空间中，随机移除一个键
    allkeys-random：直接在键空间中随机移除一个键
    volatile-ttl： 在设置了过期时间的键空间中，有更早过期时间的key优先移除
    noeviction : 不做过键处理，只返回一个写操作错误。
    
LRU算法
---
最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用

    实现：（数据结构，散列表+双向链表）
    insert: 新元素放到链表表头,其他元素顺序往下移动
    get ： 获取一个元素时，将当前访问元素移到头结点 （缓存数据被命中，将数据移动到列表头部,缓存已满的时候，移除列表尾部数据。）
    
    
 MySQL InnoDB LRU 改进算法
 ---
 将链表拆分成两部分，分为热数据区，与冷数据区
 
    1.（热数据）访问数据如果位于热数据区，与之前 LRU 算法一样，移动到热数据区的头结点。
    2.（缓存满了）插入数据时，若缓存已满，淘汰尾结点的数据。然后将数据插入冷数据区的头结点
    3. （冷数据）若该数据已在缓存中超过指定时间，比如说 1 s，则移动到热数据区的头结点
    。若该数据存在在时间小于指定的时间，则位置保持不变。
